# Simple Note: Issue

## 데이터가 변경될 때, 화면도 동일하게 변경하기

```typescript
interface Note {
  id: number;
  title: string;
  body: string;
  date: string;
}

const notes: Note[] = [];
```

`notes` 라는 변수는 사용자가 작성한 노트 데이터를 담고 있는 배열입니다.

사용자가 특정 노트를 선택하여 해당 노트의 제목을 변경했다고 가정하고, 노트 데이터를 업데이트 하겠습니다.

```typescript
notes.forEach(note => {
  if (note.id === currentNote?.id) {
    note.title = currentNote.title;
    note.body = currentNote.body;
    note.date = currentNote.date;
  }
});
```

데이터가 변경되었으니, 화면도 데이터와 일치하도록 변경해야 합니다.  
이 데이터는 사용자에게 노트 리스트로서 보여집니다.

화면을 변경할 수 있는 방법으로 2가지의 방법을 생각해봤습니다.

### 1. `innerHTML` 로 초기화 후, `render()` 함수 실행

```typescript
$noteList.innerHTML = '';
renderNoteList();
```

`renderNoteList` 함수는 `notes` 데이터를 순회하여 데이터와 일치하는 화면 요소들을 생성한 후, 이것들을 `$noteList` 의 자식 요소로서 추가합니다.

`innerHTML` 속성을 이용해 이전에 렌더링됐던 노트 리스트가 모두 삭제됐기 때문에, `notes` 의 데이터가 변경되면 항상 새로운 데이터를 화면에 렌더링해줄 수 있습니다.

### 2. 요소의 텍스트 노드를 직접 수정하기

```typescript
for (const $note of $noteList.children) {
  const title = $note.querySelector('.title');
  const cont = $note.querySelector('.cont');
  const date = $note.querySelector('.date');

  if (!(title && cont && date)) return;

  if ($note instanceof HTMLElement) {
    if (Number($note.dataset.id) !== currentNote.id) continue;
    title.textContent = currentNote?.title;
    cont.textContent = currentNote?.cont;
    date.textContent = currentNote?.date;
  }
}

$noteList.append(...$noteList.children);
```

직접 요소 노드를 순회하여 변경된 요소의 컨텐츠만 수정한 후, `append` 와 같은 삽입 메서드를 이용하면 변경된 노트 리스트로 화면이 변경됩니다.

기존의 노드들을 삽입 메서드를 이용해 다른 곳에 추가할 경우, 기존의 위치에서 이를 삭제하고 새로운 곳으로 옮기기 때문에 변경된 노트 리스트를 렌더링할 수 있습니다.

### 선택

저는 첫번째 방법을 통해 화면을 업데이트 하는 방식을 선택했습니다.

변수를 통해 데이터의 상태를 관리하기 때문에, 첫번째 방식의 코드가 데이터가 변경되면 화면을 다시 그린다는 의미가 좀 더 명확히 느껴졌습니다.
