# Simple Note: Issue

## 데이터가 변경될 때, 화면도 동일하게 변경하기

```typescript
interface Note {
  id: number;
  title: string;
  body: string;
  date: string;
}

const notes: Note[] = [];
```

`notes` 라는 변수는 사용자가 작성한 노트 데이터를 담고 있는 배열입니다.

사용자가 특정 노트를 선택하여 해당 노트의 제목을 변경했다고 가정하고, 노트 데이터를 업데이트 하겠습니다.

```typescript
notes.forEach(note => {
  if (note.id === currentNote?.id) {
    note.title = currentNote.title;
    note.body = currentNote.body;
    note.date = currentNote.date;
  }
});
```

데이터가 변경되었으니, 화면도 데이터와 일치하도록 변경해야 합니다.  
이 데이터는 사용자에게 노트 리스트로서 보여집니다.

화면을 변경할 수 있는 방법으로 2가지의 방법을 생각해봤습니다.

### 1. `innerHTML` 로 초기화 후, `render()` 함수 실행

```typescript
$noteList.innerHTML = '';
renderNoteList();
```

`renderNoteList` 함수는 `notes` 데이터를 순회하여 데이터와 일치하는 화면 요소들을 생성한 후, 이것들을 `$noteList` 의 자식 요소로서 추가합니다.

`innerHTML` 속성을 이용해 이전에 렌더링됐던 노트 리스트가 모두 삭제됐기 때문에, `notes` 의 데이터가 변경되면 항상 새로운 데이터를 화면에 렌더링해줄 수 있습니다.

### 2. 요소의 텍스트 노드를 직접 수정하기

```typescript
for (const $note of $noteList.children) {
  const title = $note.querySelector('.title');
  const cont = $note.querySelector('.cont');
  const date = $note.querySelector('.date');

  if (!(title && cont && date)) return;

  if ($note instanceof HTMLElement) {
    if (Number($note.dataset.id) !== currentNote.id) continue;
    title.textContent = currentNote?.title;
    cont.textContent = currentNote?.body;
    date.textContent = currentNote?.date;
  }
}
```

직접 요소 노드를 순회하여 변경된 요소의 컨텐츠만 수정합니다.

### 선택

첫번째 방식을 선택하였다가, 두번째 방식으로 변경하였습니다.

첫번째 방식은 이미 렌더링된 요소들을 모두 삭제한 후, 새로 화면을 다시 그리지만 두번째 방식은 변경된 노트 데이터와 관련이 있는 요소를 찾아 그 요소의 컨텐츠만을 수정하기 때문입니다.
